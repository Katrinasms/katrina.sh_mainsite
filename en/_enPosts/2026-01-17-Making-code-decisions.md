---
layout: posts
title: Making Code Decisions
description: When developing a program, I constantly face a lots of decision makings. How should I structure my functions? What’s the best way to gather data? Should I use OOP or procedural programming? Should certain parts live in the same class? Which layer should a piece of logic belong to?
lang: en
imageSrc: /assets/images/blog/making-code-decision.png
tag: [Code-frontend]
mayLikes: [Code-frontend]
---
### **My Struggle**
When developing a program, I constantly face a lots of decision makings. How should I structure my functions? What’s the best way to gather data? Should I use OOP or procedural programming? Should certain parts live in the same class? Which layer should a piece of logic belong to?

As a beginner, these choices can feel overwhelming. I often hesitate, afraid that choosing the “wrong” approach will break my program or expose how little I know.

### **What I Learned:**
Over time, I realized something important: in programming, there is rarely an absolute right or wrong answer. Most decisions are trade‑offs. A solution that looks “dumb” on paper might actually be the smartest choice for a specific situation, given the constraints, the timeline, or my current skill level.

Instead of chasing the perfect solution, I learned to focus on understanding the pros and cons of each option. Once you know the trade‑offs, you can make a decision with confidence — not because it’s flawless, but because it fits the problem you’re solving right now.

I also learned to embrace my current code, even when it’s imperfect. Looking back at old code almost always makes me think, “I could write this better now.” And that’s a good thing — it means I’m improving. Instead of feeling embarrassed about past work, I try to accept it for what it was: the best I could do with the knowledge I had at the time. Growth always makes yesterday’s code look outdated.

Writing code that is modular and flexible helps too. When your components are easy to adjust or replace, future improvements become much less painful. Even if you later learn a better approach, you can refactor without tearing everything apart.



> #### **TL;DR:** 
> There’s no universal “best” solution in programming. Every choice has upsides and downsides, and sometimes the simplest or “dumbest” option is exactly what the situation needs. Embrace your current code, learn from your past code, and focus on understanding trade‑offs instead of chasing perfection.

---